---
title: "Plot Lasagna"
author: "Juli Tkotz"
date: "16 April 2019"
output: 
  html_document:
    highlight: tango
    df_print: paged
---

First things first: Again, we have a setup chunk - which is exactly the same like in the PDF document.

```{r setup}
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, 
                      warning = FALSE, fig.align = "center")
```

## The tidyverse

The diamond data set we got in the PDF lives in the `tidyverse`. The `tidyverse` is a package in `R`, but it is a bit of an odd one. See what it does when we load it (and let the chunk show the message for once).

```{r, message = TRUE}
library(tidyverse)
```

There are several packages included in the `tidyverse` - the whole concept behind it is "tidy data", which means that data is organised in a certain way, the code is cleaned up and (supposed to be) easier to understand for people without a programming background and beginners - and there are some really nice functions included that save you some copy-pasting and frustration. It might be a bit weird at the start when you're rather a "purist", but it's worth exploring! Once you loaded the library, you can check for updates of all the `tidyverse` packages by running `tidyverse_update()`. Similarly, `install.packages("tidyverse")` will install all the packages in the `tidyverse`. You will often see stuff like this in other people's code:

```{r}
library(dplyr)
library(ggplot2)
library(tidyverse)
```

As you now know, that's completely redundant. Don't be that kind of guy. Just load the tidyverse. 

### Some quirks
Anyways. Let's work with the diamond data set again. By the way, the `tidyverse` has these nice things called tibbles. They work like `data.frames`, only if you call one, it will automatically only give you the head of the data and show you what types the variables are. Really tidy! Also, I put `df_print: paged` in the header of my document, allowing scrolling through data (also works for "normal" `data.frames`, of course).

```{r}
(diamonds <- diamonds)
```

#### Pipes
One of the main features of the `tidyverse` are pipes `%>%`. Basically, you "pipe" data into functions instead of wrapping the data in them. Importantly, you can call column names in a `data.frame` (or `tibble`) without including the name of the `data.frame` - the function already knows where it should look for the column because you piped the whole `data.frame` into it. You also don't need quotation marks. Consider the "base way" and the "tidy way" to do exactly the same thing (getting the mean price of all diamonds that have an ideal cut and the colour emerald).

```{r}
# base way
mean(diamonds$price[diamonds$cut == "Ideal" & diamonds$color == "E"])
```

```{r}
# tidy way
diamonds %>% 
  filter(cut == "Ideal", color == "E") %>% 
  summarise(mean = mean(price))
```

Also check out these nice features:

```{r}
diamonds %>% 
  filter(color %in% c("D", "E")) %>% 
  group_by(cut, color) %>%
  summarise(n = n(),
            mean = mean(price) %>% round(2), 
            sd = sd(price) %>% round(2))
```


We wanted to do plots, though. So we are in need of the help of one of the most renowed heroes of the `tidyverse`, the one that makes `R` famous for beautiful plots and figures. It's ...

## ggplot2
### Lasagna
First of all, let's work with a reduced data set because `diamonds` is huge and a bit annoying to handle with graphics. 

```{r}
diamonds_small <- diamonds %>%
  filter(color %in% c("E", "D", "J"), cut %in% c("Fair", "Very Good", "Ideal"),
         !clarity %in% c("I1", "IF", "SI2"), between(carat, .7, 2)) %>% 
  mutate(clarity = factor(clarity))
```

Graphics work in layers. Like lasagna. Our first layer is the panel which we draw on. Which essentially means empty space, so we don't see anything when we pipe our data to the `ggplot` function.

```{r}
diamonds_small %>% 
  ggplot()
```

### mapping aesthetics
Everything that has to do with mapping our data based on its properties is called aesthetics. We have to wrap our aesthetics into `aes` - we'll see why in a minute. The x- and y-coordinates are such aesthetics. However, if we map the price to the cut, we still don't see much more. `R` was so clever to draw reasonable axes and a grid, but not our data. That's because we haven't told `R` what kind of plot we would like.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price))
```

### geoms
Different types of plots are called geoms. One geom could be a barplot, a boxplot, a histogram ... you name it. For example, we could do a boxplot with `geom_boxplot`. We can add different layers to our lasagne with a `+`.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price)) +
  geom_boxplot()
```

Of course, we'd like to have some colour and stuff. We can specify them using aesthetics - but this time, they're sort of "global" aesthetics that don't have anything to do with the properties of our data. Hence, we don't wrap them in `aes` to map our data, but specify them outside of it.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price)) +
  geom_boxplot(colour = "dark red", fill = "light green", alpha = .4)
```

We could very well put the aesthetics in `aes` into `geom_col`, we don't need to; `ggplot` will just take the aesthetics from `ggplot`. The interesting point is that aesthetics work as "global" aesthetics or as mapping. For example, we can map groups in our data to the colour of our plot. That means we can easily divide our diamonds by the clarity.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price, fill = clarity)) +
  geom_boxplot(colour = "black", alpha = .4)
```

### Customisation
`ggplot` has picked some colours to fill the bars with, but we can easily specify our own colours using either their names our hex code. We just add another layer to our lasagna.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price, fill = clarity)) +
  geom_boxplot(colour = "black", alpha = .4) +
  scale_fill_manual(values = c("cadetblue3", "#F4FDD9", "#C3DBC0", "#FFDAA0", 
                               "dark green"))
```

With the same logic, we could custom the breaks of our y-axis:

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price, fill = clarity)) +
  geom_boxplot(colour = "black", alpha = .4) +
  scale_fill_manual(values = c("cadetblue3", "#F4FDD9", "#C3DBC0", "#FFDAA0", 
                               "dark green")) +
  scale_y_continuous(breaks = seq(1000, 19000, 3000))
```

Why not use different titles?

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price, fill = clarity)) +
  geom_boxplot(colour = "black", alpha = .4) +
  scale_fill_manual(values = c("cadetblue3", "#F4FDD9", "#C3DBC0", "#FFDAA0", 
                               "dark green")) +
  scale_y_continuous(breaks = seq(1000, 19000, 3000)) +
  labs(title = "My fancy plot", y = "override the y-axis title", 
       x = "this doesn't make sense")
```

With `theme()`, we can change a lot about our plots appearance. Check out these changes:

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price, fill = clarity)) +
  geom_boxplot(colour = "black", alpha = .6) +
  scale_fill_manual(values = c("cadetblue3", "#F4FDD9", "#C3DBC0", "#FFDAA0", 
                               "dark green")) +
  scale_y_continuous(breaks = seq(1000, 19000, 3000)) +
  labs(title = "My fancy plot", y = "override the y-axis title", 
       x = "this doesn't make sense") +
  theme(legend.position = "top", 
        legend.background = element_rect(fill = "light blue", colour = "dark red"),
        plot.title = element_text(face = "bold", colour = "orange", size = 14,
                                  hjust = .5),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .3),
        axis.ticks = element_blank(), 
        axis.title.y = element_text(size = 5, colour = "green"),
        panel.grid.major = element_line(colour = "dark blue", size = 2),
        panel.grid.major.y = element_line(colour = "red", size = .5),
        panel.background = element_blank())
```

### More useful
Having created the ugliest plot lasagna ever, we should probably turn to some more reasonable stuff, like combining different geoms. Let's have a scatter plot with a regression line in it.

```{r}
diamonds_small %>% 
  filter(color == "E") %>% 
  ggplot(aes(x = carat, y = price)) +
  geom_point(alpha = .2, size = 1.5) +
  geom_smooth(method = "lm")
```

Another thing that's really useful is facets. You can group your plot by one parameter ...

```{r}
diamonds_small %>% 
  filter(color == "E") %>% 
  ggplot(aes(x = carat, y = price)) +
  geom_point(alpha = .2, size = 1.5) +
  geom_smooth(method = "lm") +
  facet_grid(~clarity)
```

... or by several ones.

```{r}
diamonds_small %>% 
  filter(color == "E") %>% 
  ggplot(aes(x = carat, y = price)) +
  geom_point(alpha = .2, size = 1.5) +
  geom_smooth(method = "lm") +
  facet_grid(clarity ~ cut)
```

### Lowering the bar
What about ordinary bar plots? There are some caveats. First of all, `geom_bar` counts categories and won't take a y-coordinate.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut)) +
  geom_bar(colour = "black", fill = "cadetblue")
```

Ok, that's not entirely true. We can switch to proportions with this neat little trick.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = ..prop.., group = "dummy")) +
  geom_bar(colour = "black", fill = "cadetblue")
```

And look what happens when we group the data!

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut)) +
  geom_bar(aes(fill = color), colour = "black")
```

We can change that, though ...

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut)) +
  geom_bar(aes(fill = color), colour = "black", position = "dodge")
```

`geom_col`, on the other hand, takes x- and y-coordinates. But it behaves a bit funny. I filled it in a light blue colour, but the bars appear black and the y-axis seems messed up. In a reduced data set, you could see that the black comes from the outlines of loads of individual bars stacked into each other - because for every pair of cut/price, a bar is drawn - for all the 3689 observations in `diamonds_small`! That's stupid. We want the mean price per category. not the individual data points.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price)) +
  geom_col(colour = "black", fill = "light blue")
```

### Stats
Geoms and stats are (actually interchangeable) siblings. We can either manually set up a `data.frame` with means, sd and stuff ... or use the existing stats to do just that. By default, `stat_summary` will give us the mean. We specified `"bar"` (`"col"` would work as well) as our geom, because `stat_summary` is by default connected with `geom_pointrange`. Have a look at this [cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf) for different geoms and stats.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price)) +
  stat_summary(colour = "black", fill = "light blue", geom = "bar")
```

That means, we could do it the other way round and use `geom_bar` while specifying `"summary"` for `stat`:

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price)) +
  geom_bar(colour = "black", fill = "light blue", stat = "summary")
```

You saw that `stats_summary` is usually connected to `geom_pointrange` in a similar fashion, we can produce a bar plot with errorbars:

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price)) +
  geom_bar(colour = "black", fill = "light blue", stat = "summary") +
  geom_errorbar(stat = "summary", width = .25)
```

You could very well have your own values for xmin and ymin of your errorbars. You can also specify the functions used to generate the different values. While, for example, `stat_summary` uses mean and se (`mean_se`) by default, we can change that to the standard deviation.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price)) +
  stat_summary(fun.y = mean,
               fun.ymax = function(x) mean(x) + sd(x),
               fun.ymin = function(x) mean(x) - sd(x))
```

We can also have a grouped version - something you'd use for an ANOVA or stuff (let's use the se for this again, though). We need to add another layer to connect the dots with lines. Note that this only works if we group the data using group - only grouping it by colour will cause `ggplot` to complain. We could use only `group`, but then the different lines will not be coloured.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price, colour = color, group = color)) +
  stat_summary() +
  stat_summary(fun.y = mean, geom = "line")
```

### Let's get wild
There aren't many occasions where you can reasonably use animations in your plots. Still, it's good for impressing your peers at conferences or Twitter. There's much to be said about `gganimate` and getting into all of its functions would be a topic on its own. For now, let's consider these common examples: We can reveal a plot along its axes (if we want to keep the points we have to give them a group):

```{r}
library(gganimate)

diamonds_small %>% 
  ggplot(aes(x = cut, y = price, colour = color, group = color)) +
  stat_summary() +
  stat_summary(fun.y = mean, geom = "line") +
  transition_reveal(stat(x))
```

Or we could transition between the different degrees of clarity.

```{r}
diamonds_small %>% 
  ggplot(aes(x = cut, y = price, fill = color)) +
  geom_bar(stat = "summary", position = "dodge") +
  labs(title = "{closest_state}") +
  transition_states(clarity)
```

